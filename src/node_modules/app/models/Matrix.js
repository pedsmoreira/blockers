// @flow

import {observable} from "mobx";

export type Position = { x: number, y: number };
export type Grid<T = any> = (T | null)[][];

export default class Matrix<T = any> {
    @observable grid: Grid<T>;

    constructor(rows: number, cols: number) {
        this.grid = this.constructor.build(rows, cols);
    }

    rotate() {
        this.grid = this.rotated();
    }

    apply(grid: Grid<>, position: Position): void {
        this.constructor.apply(this.grid, grid, position);
    }

    static apply(haystack: Grid<>, needle: Grid<>, position: Position): void {
        let rows = this.rows(needle);
        let cols = this.cols(needle);

        for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
                const value = this.get(needle, {x, y});
                if (value) this.set(haystack, {x: position.x + x, y: position.y + y}, value);
            }
        }
    }

    clear(position: Position, width: number, height: number): void {
        this.constructor.clear(this.grid, position, width, height);
    }

    static clear(grid: Grid<>, position: Position, width: number, height: number): void {
        for (let x = position.x; x < position.x + width; x++) {
            for (let y = position.y; y < position.y + height; y++) {
                this.unset(grid, {x, y});
            }
        }

        for (let y = position.y - 1; y > 0; y--) {
            for (let x = position.x; x < position.x + width; x++) {
                const value = this.get(grid, {x, y});
                if (value) {
                    this.unset(grid, {x, y});
                    this.set(grid, {x, y: y + 1}, value);
                }
            }
        }
    }

    clearRow(row: number) {
        this.constructor.clearRow(this.grid, row);
    }

    static clearRow(grid: Grid<>, row: number) {
        this.clearRows(grid, row, 1);
    }

    clearRows(startingRow: number, amount: number): void {
        this.constructor.clearRows(this.grid, startingRow, amount);
    }

    static clearRows(grid: Grid<>, startingRow: number, rows: number): void {
        this.clear(grid, {x: 0, y: startingRow}, this.cols(grid), rows);
    }

    clearAll(): void {
        this.constructor.clearAll(this.grid);
    }

    static clearAll(grid: Grid<>): void {
        return this.clearRows(grid, 0, this.rows(grid));
    }

    clearFullRows(): number {
        return this.constructor.clearFullRows(this.grid);
    }

    static clearFullRows(grid: Grid<>): number {
        let count = 0;
        grid.forEach((_, y) => {
            if (this.isRowFull(grid, y)) {
                this.clearRow(grid, y);
                count++;
            }
        });
        return count;
    }

    isRowFull(row: number) {
        return this.constructor.isRowFull(this.grid, row);
    }

    static isRowFull(grid: Grid<>, row: number) {
        return grid[row].every((value) => !!value);
    }

    outOfBounds(position: Position): boolean {
        return this.constructor.outOfBounds(this.grid, position);
    }

    static outOfBounds(grid: Grid<>, position: Position): boolean {
        const cols = this.cols(grid);
        const rows = this.rows(grid);

        return position.x < 0
            || position.y < 0
            || position.x >= cols
            || position.y >= rows;
    }

    positionAvailable(position: Position): boolean {
        return this.constructor.positionAvailable(this.grid, position);
    }

    static positionAvailable(grid: Grid<>, position: Position): boolean {
        return !this.outOfBounds(grid, position) && !this.get(grid, position);
    }

    gridAvailable(grid: Grid<>, position: Position) {
        return this.constructor.gridAvailable(this.grid, grid, position);
    }

    static gridAvailable(haystack: Grid<>, needle: Grid<>, position: Position): boolean {
        const needleRows = this.rows(needle);
        const needleCols = this.cols(needle);

        const haystackRows = this.rows(haystack);
        const haystackCols = this.cols(haystack);

        for (let x = 0; x < needleCols; x++) {
            for (let y = 0; y < needleRows; y++) {
                const newPosition = {x: position.x + x, y: position.y + y};
                const outOfBottomBounds = newPosition.x < 0 || newPosition.x >= haystackCols || newPosition.y >= haystackRows;

                if (outOfBottomBounds || (newPosition.y > 0
                    && this.get(needle, {x, y})
                    && !this.positionAvailable(haystack, newPosition))) return false;
            }
        }

        return true;
    }

    landingGridPosition(grid: Grid<>, position: Position): Position {
        return this.constructor.landingGridPosition(this.grid, grid, position);
    }

    static landingGridPosition(haystack: Grid<>, needle: Grid<>, position: Position): Position {
        let y = position.y;

        while (this.gridAvailable(haystack, needle, {x: position.x, y: y + 1})) {
            y++;
        }

        return {x: position.x, y: y};
    }

    rotated() {
        return this.constructor.rotated(this.grid);
    }

    static rotated(grid: Grid<>): Grid<> {
        let result: Array<any> = [];

        grid.forEach(row => {
            row.forEach((value, j) => {
                if (result.length === j) result.push([]);
                result[j].unshift(value)
            })
        });

        return result
    }

    rows(): number {
        return this.constructor.rows(this.grid);
    }

    static rows(grid: Grid<>): number {
        return grid.length;
    }

    cols(): number {
        return this.constructor.cols(this.grid);
    }

    static cols(grid: Grid<>): number {
        return grid.length > 0 ? grid[0].length : 0;
    }

    get(position: Position): Grid<T> {
        return this.constructor.get(this.grid, position);
    }

    static get(grid: Grid<>, position: Position): any {
        return this.outOfBounds(grid, position) ? null : grid[position.y][position.x];
    }

    set(position: Position, value: T): void {
        this.constructor.set(this.grid, position, value);
    }

    static set(grid: Grid<>, position: Position, value: any): void {
        if (!this.outOfBounds(grid, position)) grid[position.y][position.x] = value;
    }

    unset(position: Position): void {
        this.constructor.unset(this.grid, position);
    }

    static unset(grid: Grid<>, position: Position): void {
        this.set(grid, position, null);
    }

    each(callback: Function): void {
        this.constructor.each(this.grid, callback);
    }

    static each(grid: Grid<>, callback: Function): void {
        this.map(grid, callback);
    }

    eachValue(callback: Function): void {
        return this.constructor.eachValue(this.grid, callback);
    }

    static eachValue(grid: Grid<>, callback: Function): void {
        this.mapValue(grid, callback);
    }

    map(callback: Function): Grid<T> {
        return this.constructor.map(this.grid, callback);
    }

    static map(grid: Grid<>, callback: Function): Grid<> {
        return grid.map((row, y) => row.map((value, x) => callback(value, {x, y})));
    }

    mapValue(callback: Function): Grid<> {
        return this.constructor.mapValue(this.grid, callback);
    }

    static mapValue(grid: Grid<>, callback: Function): Grid<> {
        let result = [];

        grid.forEach((row, y) => row.forEach((value, x) => {
            if (value) result.push(callback(value, {x, y}));
        }));

        return result;
    }

    build(): Grid<T> {
        return this.constructor.build(this.rows(), this.cols());
    }

    static build(rows: number, cols: number): Grid<> {
        let result = [];
        for (let y = 0; y < rows; y++) result.push(Array(cols).fill(null));
        return result;
    }

    concat(grid: Grid<T>, position: Position): Matrix<T> {
        return this.constructor.concat(this.grid, grid, position);
    }

    static concat(haystack: Grid<>, needle: Grid<>, position: Position): Matrix<> {
        let matrix: Matrix<> = new Matrix(this.rows(haystack), this.cols(haystack));
        matrix.apply(haystack, {x: 0, y: 0});
        matrix.apply(needle, position);

        return matrix;
    }

    print(): void {
        this.constructor.print(this.grid);
    }

    static print(grid: Grid<>): void {
        grid.forEach((row, y) => {
            const content = row.map((value, x) => this.get(grid, {x, y}) ? 'x' : ' ');
            console.log((y < 10 ? '0' + y : y) + ': ' + content.join(' | '))
        })
    }

    clearPrint(): void {
        this.constructor.clearPrint(this.grid);
    }

    static clearPrint(grid: Grid<>): void {
        console.clear();
        this.print(grid);
    }
}
