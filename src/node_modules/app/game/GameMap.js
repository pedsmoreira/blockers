// @flow

import Piece from "app/game/Piece";
import Block from "app/game/Block";
import type {Position} from "app/game/Matrix";
import Matrix from "app/game/Matrix";

export default class GameMap {
    matrix: Matrix<Block>;

    piece: Piece;
    piecePosition: Position;

    constructor(rows: number, cols: number) {
        this.matrix = new Matrix(rows, cols);
    }

    handlePiece(piece: Piece, piecePosition: Position | null = null) {
        this.piece = piece;
        this.piecePosition = piecePosition || this.randomPieceOrigin();
    }

    randomPieceOrigin(): Position {
        return {
            x: Math.floor(Math.random() * (this.matrix.cols() - this.piece.matrix.cols())),
            y: -this.piece.matrix.rows()
        }
    }

    rotatePiece(): boolean {
        if (this.matrix.gridAvailable(this.piece.matrix.rotated(), this.piecePosition)) {
            this.piece.matrix.rotate();
            return true;
        }

        return false;
    }

    movePiece(x: number, y: number): boolean {
        let newPosition = this.pieceMovementPosition(x, y);
        this.matrix.gridAvailable(this.piece.matrix.grid, newPosition);
        this.piecePosition = newPosition;
        return true;
    }

    decayPiece(): boolean {
        return this.movePiece(0, 1);
    }

    dropPiece(): void {
        if (this.decayPiece()) this.dropPiece();
    }

    applyPiece(): void {
        this.matrix.apply(this.piece.matrix.grid, this.piecePosition);
    }

    matrixWithPiece(): Matrix<Block> {
        return this.matrix.concat(this.piece.matrix.grid, this.piecePosition);
    }

    pieceMovementPosition(x: number, y: number): Position {
        return {x: this.piecePosition.x + x, y: this.piecePosition.y + y};
    }

    pieceDecayPosition() {
        return this.pieceMovementPosition(0, 1);
    }
}
