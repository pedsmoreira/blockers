// @flow

export type Position = { x: number, y: number };
export type Grid<T = any> = (T | null)[][];

export default class Matrix<T = any> {
    grid: Grid<T>;

    constructor(rows: number, cols: number) {
        this.grid = this.constructor.build(rows, cols);
    }

    rotate() {
        this.grid = this.rotated();
    }

    apply(grid: Grid<T>, position: Position): void {
        this.constructor.apply(this.grid, grid, position);
    }

    static apply(haystack: Grid<>, needle: Grid<>, position: Position): void {
        let rows = this.rows(needle);
        let cols = this.cols(needle);

        for (let x = position.x; x < cols; x++) {
            for (let y = position.y; y < rows; y++) {
                this.set(haystack, {x, y}, this.get(needle, {x, y}));
            }
        }
    }

    clear(position: Position, width: number, height: number): void {
        this.constructor.clear(this.grid, position, width, height);
    }

    static clear(grid: Grid<>, position: Position, width: number, height: number): void {
        for (let x = position.x; x < position.x + width; x++) {
            for (let y = position.y; y < position.y + height; y++) {
                this.unset(grid, {x, y});
            }
        }
    }

    clearRow(row: number) {
        this.constructor.clearRow(this.grid, row);
    }

    static clearRow(grid: Grid<>, row: number) {
        this.clearRows(grid, row, 1);
    }

    clearRows(startingRow: number, amount: number): void {
        this.constructor.clearRows(this.grid, startingRow, amount);
    }

    static clearRows(grid: Grid<>, startingRow: number, amount: number): void {
        this.clear(grid, {x: startingRow, y: 0}, amount, this.cols(grid));
    }

    clearAll(): void {
        this.constructor.clearAll(this.grid);
    }

    static clearAll(grid: Grid<>): void {
        return this.clearRows(grid, 0, this.rows(grid));
    }

    clearFullRows(): number {
        return this.constructor.clearFullRows(this.grid);
    }

    static clearFullRows(grid: Grid<>): number {
        let count = 0;
        grid.forEach((_, j) => {
            if (this.isRowFull(grid, j)) {
                this.clearRow(grid, j);
                count++;
            }
        });
        return count;
    }

    isRowFull(row: number) {
        return this.constructor.isRowFull(this.grid, row);
    }

    static isRowFull(grid: Grid<>, row: number) {
        return grid[row].every((value) => !!value);
    }

    outOfBounds(position: Position): boolean {
        return this.constructor.outOfBounds(this.grid, position);
    }

    static outOfBounds(grid: Grid<>, position: Position): boolean {
        let cols = this.cols(grid);
        let rows = this.rows(grid);
        return position.x < 0 || position.y < 0 || position.x >= cols || position.y >= rows;
    }

    positionAvailable(position: Position): boolean {
        return this.constructor.positionAvailable(this.grid, position);
    }

    static positionAvailable(grid: Grid<>, position: Position): boolean {
        return !this.get(grid, position);
    }

    gridAvailable(grid: Grid<>, position: Position) {
        return this.constructor.gridAvailable(this.grid, grid, position);
    }

    static gridAvailable(haystack: Grid<>, needle: Grid<>, position: Position): boolean {
        let rows = this.rows(needle);
        let cols = this.cols(needle);

        for (let x = position.x; x < cols; x++) {
            for (let y = position.y; y < rows; y++) {
                if (!this.positionAvailable(haystack, {x, y})) return false;
            }
        }

        return true;
    }

    rotated() {
        return this.constructor.rotated(this.grid);
    }

    static rotated(grid: Grid<>): Grid<> {
        let result: Grid<> = Array(this.cols(grid));

        grid.forEach(row => {
            row.forEach((value, j) => result[j].unshift(value));
        });

        return result;
    }

    rows(): number {
        return this.constructor.rows(this.grid);
    }

    static rows(grid: Grid<>): number {
        return grid.length;
    }

    cols(): number {
        return this.constructor.cols(this.grid);
    }

    static cols(grid: Grid<>): number {
        return grid.length > 0 ? grid[0].length : 0;
    }

    get(position: Position): Grid<T> {
        return this.constructor.get(this.grid, position);
    }

    static get(grid: Grid<>, position: Position): any {
        return this.outOfBounds(grid, position) ? null : grid[position.y][position.x];
    }

    set(position: Position, value: Grid<T>): void {
        this.constructor.set(this.grid, position, value);
    }

    static set(grid: Grid<>, position: Position, value: any): void {
        if (!this.outOfBounds(grid, position)) grid[position.y][position.x] = value;
    }

    unset(position: Position): void {
        this.constructor.unset(this.grid, position);
    }

    static unset(grid: Grid<>, position: Position): void {
        this.set(grid, position, null);
    }

    each(callback: Function): void {
        this.constructor.each(this.grid, callback);
    }

    static each(grid: Grid<>, callback: Function): void {
        grid.forEach((row, y) => row.forEach((value, x) => callback(value, x, y)));
    }

    eachValue(callback: Function): void {
        return this.constructor.eachValue(this.grid, callback);
    }

    static eachValue(grid: Grid<>, callback: Function): void {
        this.each(grid, (value, x, y) => {
            if (value) callback(value, x, y);
        });
    }

    map(callback: Function): Grid<T> {
        return this.constructor.map(this.grid, callback);
    }

    static map(grid: Grid<>, callback: Function): Grid<> {
        return grid.map((row, y) => row.map((value, x) => callback(value, x, y)));
    }

    build(): Grid<T> {
        return this.constructor.build(this.rows(), this.cols());
    }

    static build(rows: number, cols: number): Grid<> {
        let result = [];
        for (let y = 0; y < rows; y++) result.push(Array(cols).fill(null));
        return result;
    }

    concat(grid: Grid<T>, position: Position): Matrix<T> {
        return this.constructor.concat(this.grid, grid, position);
    }

    static concat(haystack: Grid<>, needle: Grid<>, position: Position): Matrix<> {
        let matrix: Matrix<T> = new Matrix(this.rows(haystack), this.cols(haystack));
        matrix.apply(haystack, {x: 0, y: 0});
        matrix.apply(needle, position);

        return matrix;
    }
}
