import {action, computed, observable} from "mobx";
import Store from "app/stores/Store";
import TimePlayer from "app/utils/TimePlayer";

import Character from "app/game/Character";
import Piece from "app/game/Piece";
import Spell from "app/game/Spell";
import Block from "app/game/Block";
import type {Position} from "app/game/Matrix";
import Matrix from "app/game/Matrix";

import * as gameStates from "app/config/gameStates";
import * as gameProperties from "app/config/gameProperties";

import MoveEvent from "app/game/events/MoveEvent";
import CastEvent from "app/game/events/CastEvent";

import ControlManager from "app/controls/ControlManager";
import KeyboardControl from "app/controls/KeyboardControl";

import Batman from "app/game/characters/Batman";

class GameStore extends Store {
    character: Character = new Batman();
    controlManager: ControlManager;

    piece: Piece;

    @observable state: string;
    @observable level: number = 1;
    @observable piecePosition: Position;
    @observable matrix: Matrix<Block>;

    timer: TimePlayer;

    constructor() {
        super();

        this.controlManager = new ControlManager({
                move: this.move.bind(this),
                drop: this.drop.bind(this),
                rotate: this.rotate.bind(this),
                cast: this.cast.bind(this),
                pause: this.pause.bind(this),
                resume: this.resume.bind(this)
            },
            [KeyboardControl]
        );
    }

    /*
     * Control driven actions
     */

    @action move(x: number, y: number): boolean {
        if (!this.playing) return false;

        if (x > 0 && y > 0) y = 0;

        let newPosition = {x: this.piecePosition.x + x, y: this.piecePosition.y + y};
        let canMove = this.matrix.gridAvailable(this.piece.grid, newPosition);

        if (!canMove) {
            if (y > 0) {
                if (this.piecePosition.y < 0) {
                    this.gameOver();
                } else {
                    this.newPiece();
                }
            }

            return false;
        }

        if (y > 0) {
            this.timer.reset();
        }

        let event = new MoveEvent(this.piecePosition, newPosition, false);
        if (!event.fireBefore()) return false;

        this.piecePosition = newPosition;
        event.fire();

        return true;
    }

    @action drop(): void {
        const y = this.matrix.landingGridPosition(this.piece.grid, this.piecePosition).y - this.piecePosition.y;
        this.move(0, y);
        this.decay();
    }

    @action rotate(): void {
        if (!this.playing || !this.matrix.gridAvailable(this.piece.rotated(), this.piecePosition)) return;

        this.piece.rotate();
        // let event = new RotateEvent();
    }

    @action cast(spell: Spell): void {
        if (!spell.canCast()) return;

        let event = new CastEvent(spell);
        if (!event.fireBefore()) return;

        spell.cast();
        event.fire();
    }

    @action resume(): void {
        if (!this.paused) return;

        this.state = gameStates.PLAYING;
        this.timer.play();
    }

    @action pause(): void {
        if (!this.playing) return;

        this.timer.pause();
        this.state = gameStates.PAUSED;
    }

    /*
     * State changing actions
     */

    @action play(): void {
        this.matrix = new Matrix(gameProperties.ROWS, gameProperties.COLS);

        this.newPiece();
        this.state = gameStates.PLAYING;

        this.timer = new TimePlayer(gameProperties.SPEED, () => this.decay());
        this.timer.play();

        for (let x = 0; x < 12; x++) {
            this.matrix.set({x, y: 19}, new Block(null, null));
        }

        for (let x = 0; x < 10; x++) {
            this.matrix.set({x, y: 18}, new Block(null, null));
        }
    }

    @action gameOver(): void {
        this.state = gameStates.LOSS;
        this.timer.pause();
        alert('Game Over');
    }

    /*
     * Internal actions and actions available for spells
     */

    @action newPiece(piece: Piece = Piece.random(), piecePosition: Position | null = null): void {
        if (this.piece) this.matrix.apply(this.piece.grid, this.piecePosition);

        if (!piecePosition) piecePosition = {
            x: Math.floor(Math.random() * (this.matrix.cols() - piece.cols())),
            y: -piece.rows()
        };

        this.piece = piece;
        this.piecePosition = piecePosition;

        this.matrix.clearFullRows();
    }

    @action decay(): boolean {
        return this.move(0, 1);
    }

    @action levelUp(): void {
        this.character.level++;
        this.timer.accelerate(gameProperties.SPEED * gameProperties.SPEED_FACTOR);
    }

    /*
     * State shortcuts
     */

    @computed get playing(): boolean {
        return this.state === gameStates.PLAYING;
    }

    @computed get paused(): boolean {
        return this.state === gameStates.PAUSED;
    }
}

export default new GameStore();
