// @flow

import {action, computed, observable, reaction} from "mobx";
import Store from "app/stores/Store";

import Character from "app/models/Character";
import Piece from "app/models/Piece";
import Spell from "app/models/Spell";
import Block from "app/models/Block";
import type {Position} from "app/models/Matrix";
import Matrix from "app/models/Matrix";
import Effect from "app/models/Effect";
import Stage from "app/models/Stage";
import Timer from "app/models/Timer";

import * as gameStates from "app/constants/gameStates";
import * as gameProperties from "app/constants/gameProperties";
import * as gameModes from "app/constants/gameModes";

import MoveEvent from "app/game/events/MoveEvent";
import CastEvent from "app/game/events/CastEvent";

import ControlManager from "app/controls/ControlManager";
import KeyboardControl from "app/controls/KeyboardControl";

class GameStore extends Store {
    characterClass: Function;
    @observable character: Character;

    stageClass: Function;
    @observable stage: Stage;

    @observable state: string;
    @observable mode: string = gameModes.SURVIVAL;
    @observable piece: Piece;
    @observable piecePosition: Position;

    @observable linesCleared = 0;
    @observable combo: number = 0;

    @observable matrix: Matrix<Block>;
    @observable effects: Effect[] = [];

    controlManager: ControlManager;
    timer: Timer;

    constructor() {
        super();

        this.controlManager = new ControlManager({
            move: this.move,
            drop: this.drop,
            rotate: this.rotate,
            cast: this.cast,
            pause: this.pause,
            resume: this.resume
        }, [KeyboardControl]);
    }

    /*
     * Control driven actions
     */

    @action.bound move(x: number, y: number): boolean {
        if (!this.playing) return false;

        if (x > 0 && y > 0) y = 0;

        let newPosition = {x: this.piecePosition.x + x, y: this.piecePosition.y + y};
        let canMove = this.matrix.gridAvailable(this.piece.grid, newPosition);

        if (!canMove) {
            if (y > 0) {
                if (this.piecePosition.y < 0) {
                    this.gameOver();
                } else {
                    this.newPiece();
                }
            }

            return false;
        }

        if (y > 0) {
            this.timer.reset();
        }

        let event = new MoveEvent(this.piecePosition, newPosition);
        if (!event.fireBefore()) return false;

        this.piecePosition = newPosition;
        event.fire();

        return true;
    }

    @action.bound drop(): void {
        const y = this.matrix.landingGridPosition(this.piece.grid, this.piecePosition).y - this.piecePosition.y;
        this.move(0, y);
        this.decay();
        this.newPiece();
    }

    @action.bound rotate(): void {
        if (!this.playing || !this.matrix.gridAvailable(this.piece.rotated(), this.piecePosition)) return;

        this.piece.rotate();
        // let event = new RotateEvent();
    }

    @action cast(spell: Spell): void {
        if (!spell.canCast()) return;

        let event = new CastEvent(spell);
        if (!event.fireBefore()) return;

        spell.cast();
        event.fire();
    }

    @action.bound resume(): void {
        if (!this.paused) return;

        this.state = gameStates.PLAYING;
        this.timer.play();
    }

    @action.bound pause(): void {
        if (!this.playing) return;

        this.timer.stop();
        this.state = gameStates.PAUSED;
    }

    /*
     * Menu actions
     */
    @action selectCharacter(characterClass: Function) {
        this.characterClass = characterClass;
    }

    @action selectStage(stageClass: Function) {
        this.stageClass = stageClass;
    }

    /*
     * State changing actions
     */

    @action play(): void {
        this.matrix = new Matrix(gameProperties.ROWS, gameProperties.COLS);

        this.state = gameStates.PLAYING;

        this.character = new this.characterClass();
        this.stage = new this.stageClass();
        this.newPiece();

        this.timer = new Timer(this.delay, () => this.decay());
        this.timer.play();

        reaction(() => this.delay, () => this.timer.interval = this.delay);
    }

    @action gameOver(): void {
        this.state = gameStates.LOSS;
        this.effects = [];
        this.timer.pause();
        alert('Game Over');
    }

    /*
     * Internal actions and actions available for spells
     */

    @action newPiece(piece: Piece | null = null, piecePosition: Position | null = null): void {
        if (!this.playing) return;

        piece = piece || Piece.random(this.character);
        if (this.piece) this.matrix.apply(this.piece.grid, this.piecePosition);

        if (!piecePosition) piecePosition = {
            x: Math.floor(Math.random() * (this.matrix.cols() - piece.cols())),
            y: -piece.rows()
        };

        this.piece = piece;
        this.piecePosition = piecePosition;

        const fullRowsCount = this.matrix.clearFullRows();
        if (fullRowsCount) {
            this.linesCleared += fullRowsCount;
            this.score(fullRowsCount);
        } else {
            this.combo = 0;
        }
    }

    @action score(rows: number): number {
        const points = gameProperties.SCORE_FORMULA(rows, this.difficulty, this.combo);

        this.character.experience += points;
        this.combo++;

        return points;
    }

    @action decay(): boolean {
        return this.move(0, 1);
    }

    @action addEffect(effect: Effect, duration: number = 0): void {
        this.effects.push(effect);

        if (duration) {
            setTimeout(() => {
                const index = this.effects.indexOf(effect);
                if (index !== -1) this.effects.splice(index, 1);
            }, duration);
        }
    }

    /*
     * Calculations
     */
    @computed get difficulty(): number {
        return gameProperties.DIFFICULTY_FORMULA(this.linesCleared);
    }

    @computed get delay(): number {
        return gameProperties.DELAY_FORMULA(this.difficulty);
    }

    /*
     * State shortcuts
     */

    @computed get playing(): boolean {
        return this.state === gameStates.PLAYING;
    }

    @computed get paused(): boolean {
        return this.state === gameStates.PAUSED;
    }
}

export default new GameStore();
