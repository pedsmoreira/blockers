import {action, computed, observable} from "mobx";
import Store from "app/stores/Store";
import TimePlayer from "app/utils/TimePlayer";

import Character from "app/game/Character";
import Piece from "app/game/Piece";
import Spell from "app/game/Spell";
import Block from "app/game/Block";
import type {Position} from "app/game/Matrix";
import Matrix from "app/game/Matrix";
import Effect from "app/game/Effect";
import Stage from "app/game/Stage";

import * as gameStates from "app/constants/gameStates";
import * as gameProperties from "app/constants/gameProperties";

import MoveEvent from "app/game/events/MoveEvent";
import CastEvent from "app/game/events/CastEvent";

import ControlManager from "app/controls/ControlManager";
import KeyboardControl from "app/controls/KeyboardControl";

class GameStore extends Store {
    characterClass: Function;
    character: Character;

    stageClass: Function;
    stage: Stage;

    controlManager: ControlManager;

    @observable piece: Piece;

    @observable state: string;
    @observable level: number = 1;
    @observable piecePosition: Position;
    @observable matrix: Matrix<Block>;
    @observable effects: Effect[] = [];

    timer: TimePlayer;

    constructor() {
        super();

        this.controlManager = new ControlManager({
                move: this.move.bind(this),
                drop: this.drop.bind(this),
                rotate: this.rotate.bind(this),
                cast: this.cast.bind(this),
                pause: this.pause.bind(this),
                resume: this.resume.bind(this)
            },
            [KeyboardControl]
        );
    }

    /*
     * Menu actions
     */
    @action selectCharacter(characterClass: Function) {
        this.characterClass = characterClass;
    }

    @action selectStage(stageClass: Function) {
        this.stageClass = stageClass;
    }

    /*
     * Control driven actions
     */

    @action move(x: number, y: number): boolean {
        if (!this.playing) return false;

        if (x > 0 && y > 0) y = 0;

        let newPosition = {x: this.piecePosition.x + x, y: this.piecePosition.y + y};
        let canMove = this.matrix.gridAvailable(this.piece.grid, newPosition);

        if (!canMove) {
            if (y > 0) {
                if (this.piecePosition.y < 0) {
                    this.gameOver();
                } else {
                    this.newPiece();
                }
            }

            return false;
        }

        if (y > 0) {
            this.timer.reset();
        }

        let event = new MoveEvent(this.piecePosition, newPosition, false);
        if (!event.fireBefore()) return false;

        this.piecePosition = newPosition;
        event.fire();

        return true;
    }

    @action drop(): void {
        const y = this.matrix.landingGridPosition(this.piece.grid, this.piecePosition).y - this.piecePosition.y;
        this.move(0, y);
        this.decay();
        this.newPiece();
    }

    @action rotate(): void {
        if (!this.playing || !this.matrix.gridAvailable(this.piece.rotated(), this.piecePosition)) return;

        this.piece.rotate();
        // let event = new RotateEvent();
    }

    @action cast(spell: Spell): void {
        if (!spell.canCast()) return;

        let event = new CastEvent(spell);
        if (!event.fireBefore()) return;

        spell.cast();
        event.fire();
    }

    @action resume(): void {
        if (!this.paused) return;

        this.state = gameStates.PLAYING;
        this.timer.play();
    }

    @action pause(): void {
        if (!this.playing) return;

        this.timer.pause();
        this.state = gameStates.PAUSED;
    }

    /*
     * State changing actions
     */

    @action play(): void {
        this.matrix = new Matrix(gameProperties.ROWS, gameProperties.COLS);

        this.state = gameStates.PLAYING;

        this.character = new this.characterClass();
        this.stage = new this.stageClass();
        this.newPiece();

        this.timer = new TimePlayer(gameProperties.SPEED, () => this.decay());
        this.timer.play();
    }

    @action gameOver(): void {
        this.state = gameStates.LOSS;
        this.effects = [];
        this.timer.pause();
        alert('components Over');
    }

    /*
     * Internal actions and actions available for spells
     */

    @action newPiece(piece: Piece = null, piecePosition: Position | null = null): void {
        if (!this.playing) return;

        piece = piece || Piece.random(this.character);
        if (this.piece) this.matrix.apply(this.piece.grid, this.piecePosition);

        if (!piecePosition) piecePosition = {
            x: Math.floor(Math.random() * (this.matrix.cols() - piece.cols())),
            y: -piece.rows()
        };

        this.piece = piece;
        this.piecePosition = piecePosition;

        this.matrix.clearFullRows();
    }

    @action decay(): boolean {
        return this.move(0, 1);
    }

    @action levelUp(): void {
        this.character.level++;
        this.timer.accelerate(gameProperties.SPEED * gameProperties.SPEED_FACTOR);
    }

    @action addEffect(effect: Effect, duration = null): void {
        this.effects.push(effect);

        if (duration) {
            setTimeout(() => {
                const index = this.effects.indexOf(effect);
                if (index !== -1) this.effects.splice(index, 1);
            }, duration);
        }
    }

    /*
     * State shortcuts
     */

    @computed get playing(): boolean {
        return this.state === gameStates.PLAYING;
    }

    @computed get paused(): boolean {
        return this.state === gameStates.PAUSED;
    }
}

export default new GameStore();
